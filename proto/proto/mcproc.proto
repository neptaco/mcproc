syntax = "proto3";

package mcproc;

import "google/protobuf/timestamp.proto";

// Process status enum
enum ProcessStatus {
  PROCESS_STATUS_UNKNOWN = 0;
  PROCESS_STATUS_STARTING = 1;
  PROCESS_STATUS_RUNNING = 2;
  PROCESS_STATUS_STOPPING = 3;
  PROCESS_STATUS_STOPPED = 4;
  PROCESS_STATUS_FAILED = 5;
}

// Process information
message ProcessInfo {
  string id = 1;
  string name = 2;
  string cmd = 3;
  string cwd = 4;
  ProcessStatus status = 5;
  google.protobuf.Timestamp start_time = 6;
  optional uint32 pid = 7;
  string log_file = 8;
  string project = 9;
  repeated uint32 ports = 10;  // Listening ports
  optional bool wait_timeout_occurred = 11;  // True if wait_for_log timed out
}

// Request messages
message StartProcessRequest {
  string name = 1;
  // Either cmd or args must be provided
  optional string cmd = 2;  // Shell command (e.g., "npm run dev")
  repeated string args = 5; // Command args array (e.g., ["npm", "run", "dev"])
  optional string cwd = 3;
  map<string, string> env = 4;
  optional string project = 6; // Project name (defaults to directory name)
  optional string wait_for_log = 7;  // Wait for this log pattern before considering the process ready (regex)
  optional uint32 wait_timeout = 8;  // Timeout for log wait in seconds (default: 30)
}

message StopProcessRequest {
  string name = 1;
  optional bool force = 2;
  optional string project = 3;
}

message RestartProcessRequest {
  string name = 1;
  optional string project = 2;
}

message GetProcessRequest {
  string name = 1;
  optional string project = 2;
}

message ListProcessesRequest {
  optional ProcessStatus status_filter = 1;
  optional string project_filter = 2;
}

message GetLogsRequest {
  string name = 1;
  optional uint32 tail = 2;  // Number of lines from the end (default: 100)
  optional bool follow = 3;  // Continue streaming new log lines
  optional string project = 4;
}

message GrepLogsRequest {
  string name = 1;
  string pattern = 2;
  optional string project = 3;
  optional uint32 context = 4;  // Lines before and after (default: 3)
  optional uint32 before = 5;   // Lines before match
  optional uint32 after = 6;    // Lines after match
  optional string since = 7;    // Time filter: since this time
  optional string until = 8;    // Time filter: until this time
  optional string last = 9;     // Time filter: last duration (e.g., "1h", "30m")
}

// Response messages
message StartProcessResponse {
  oneof response {
    LogEntry log_entry = 1;      // Streaming log entries during wait_for_log
    ProcessInfo process = 2;      // Final process info when ready
  }
}

message StopProcessResponse {
  bool success = 1;
  optional string message = 2;
}

message RestartProcessResponse {
  ProcessInfo process = 1;
}

message GetProcessResponse {
  ProcessInfo process = 1;
}

message ListProcessesResponse {
  repeated ProcessInfo processes = 1;
}

message LogEntry {
  uint32 line_number = 1;
  string content = 2;
  google.protobuf.Timestamp timestamp = 3;
  enum LogLevel {
    LOG_LEVEL_UNKNOWN = 0;
    LOG_LEVEL_STDOUT = 1;
    LOG_LEVEL_STDERR = 2;
  }
  LogLevel level = 4;
}

message GetLogsResponse {
  repeated LogEntry entries = 1;
}

message GrepMatch {
  LogEntry matched_line = 1;
  repeated LogEntry context_before = 2;
  repeated LogEntry context_after = 3;
}

message GrepLogsResponse {
  repeated GrepMatch matches = 1;
}

// Service definition
service ProcessManager {
  rpc StartProcess(StartProcessRequest) returns (stream StartProcessResponse);
  rpc StopProcess(StopProcessRequest) returns (StopProcessResponse);
  rpc RestartProcess(RestartProcessRequest) returns (RestartProcessResponse);
  rpc GetProcess(GetProcessRequest) returns (GetProcessResponse);
  rpc ListProcesses(ListProcessesRequest) returns (ListProcessesResponse);
  rpc GetLogs(GetLogsRequest) returns (stream GetLogsResponse);
  rpc GrepLogs(GrepLogsRequest) returns (GrepLogsResponse);
}